主题：vue3的双向绑定
背景 ：“Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题”。
1.命令式和声明式
    视图层的框架分为命令式和响应式。
    命令式：代表 jquery 特点 关注过程 。自然语音描述能够与代码产生一一对应的关系 代码本身描述的是做事情的过程，符合逻辑直觉
    声明式：特点 关注结果。  以结果为导向，实现的过程有声明式的框架进行实现
    vuejs封装了过程 ，所以 vue的内部实现是 命令式 ，但是暴露处理的却是声明式的
    
2.实现一个简单的响应式
    概念：
        副作用函数：副作用函数指的是会产生副作用的函数，a函数的执行会直觉或间接影响了其他函数的执行，我们说a函数产生了副作用。 例如一个函数修改了全局变量 这也是一个副作用
        响应式数据：当值变化后，副作用函数自动重新执行，实现了这个模板，那么这个对象就是响应式数据
    设计一个响应式数据
        响应式数据特点
            1.当副作用函数执行时，会触发自动obj.text的读取操作
            2.当修改obj.text时 会触发obj.text的设置操作
        当拦截对象的读取和设置操作，就实现了一个简单的响应式 -> demo1  控制台修改对象的属性时，页面更新  满足了最基本的一个响应式的条件
    响应式系统
        系统的工作流程
            读取操作时，将副作用收集到“桶”中
            设置操作发生时 将桶中的副作用函数取出并执行
        demo1的缺点：副作用函数名称固定，导致函数名称不一致时无法执行
        方案，将命名函数改为立即执行函数


所以双向绑定可以分成多步实现 
1.实现数据监听器，能够对 数据对象的所有属性进行监听，有变动时可以拿到最新值并通知订阅者    ---Observer
2.指令器,对每个元素节点对指令进行扫描，根据指令模板替换数据并绑定相应对更新函数           ---Compile
3.监听者，连接数据监听器和指令解析器，能够订阅并收到属性变动对通知没执行指令绑定的回调函数，更新视图
4.mvvm入口函数，整合上边三步

2.vue2的双向绑定和vue3的双向绑定
    vue2:实质上是通过Object.defineProperty()对属性对劫持达到监听数据变动对目的
        Vue2 文档中介绍响应式的图片。从 Vue2 的源码角度来对照图片说一说。在 Vue2 的源码中的 src/core 路径下有一个 observer 模块，它就是 Vue2 中处理响应式的地方了。在这个模块下 observer 负责将对象、数组转换成响应式的，即图中的紫色部分，处理 Data 的 getter 及 setter。当 data 中的选项被访问时，会触发 getter，此时 observer 目录下的 wather.js  模块就会开始工作，它的任务就是收集依赖，我们收集到的依赖是一个个 Dep 类的实例化对象。而 data 中的选项变更时，会触发 setter 的调用，而在 setter 的过程中，触发 dep 的 notify 函数，派发更新事件，由此实现数据的响应监听。

    vue3:通过proxy代理对象
对比
    1.Proxy 作为新标准将受到浏览器厂商重点持续的性能优化
    2.Proxy 能观察的类型比 defineProperty 更丰富
    3.Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9
    4.Object.definedProperty 是劫持对象的属性，新增元素需要再次 definedProperty。而 Proxy 劫持的是整个对象，不需要做特殊处理
    5.使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截

4.object和proxy
    Vue3 将使用 ES6的Proxy 作为其观察者机制，取代之前使用的Object.defineProperty。
    Object.defineProperty方法存在一定的局限性，Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组
        vue通过重新实现方法达到可以监听的目地push()，pop()，shift()，unshift()，splice()，sort()，reverse()
    Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue里，是通过递归以及遍历data对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象，不管是对操作性还是性能都会有一个很大的提升。

Proxy 是ES6中新增的一个特性，可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。
var proxy = new Proxy(target, handler);
1、target: 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。
2、handler: 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。
Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法

可调度性：当触发副作用函数执行时有能力决定副作用函数当执行时机，次数以及方式
任务队列 是一个set数据结构 目的是利用set数据结构当自动去重能力。执行调度时将副作用函数加到任务队列里 然后调用 flushjob 函数刷新队列  flushjob 通过isFlushing标志判断是否执行 false时执行 执行后标志变为 true 即 单个周期内只会执行一次

计算属性
    懒加载 lazy：懒执行的副作用函数
    计算属性将 副作用函数的计算结果进行存储 ，然后设置标志用于判断是否需要重新计算值 标志初始为true 需要执行计算 标志在执行后变为false 当依赖项更新后在 调度器中将标志设置为true 然后重新计算

watch
    watch的本质就是观测一个响应式的数据，然后在数据发生变化的时候通知并执行相应的回调函数。
    数据读取时 与数据创建联系 然后数据变化时执行回调函数

过期的副作用
    多次或频繁操作数据时可能会产生 竞态问题 
    解决方法 定义清理变量 将过期函数进行清理 当过期函数当结果返回时 其结果会被抛弃

深响应和浅响应 
    props传入当数据 对象可修改 基础数据类型不能修改

toRaw方法是把被reactive或readonly后的Proxy对象转换为原来的target对象，而markRaw则直接让target不能被reactive或readonly
5.vue3的响应式基础api

vue代码
compiler-core 模板解析核心，与具体环境无关，主要生成 AST，并根据 AST 生成 render() 方法
compiler-dom 浏览器环境中的模板解析逻辑，如处理 HTML 转义、处理 v-model 等指令
compiler-sfc 负责解析 Vue 单文件组件，在前面 vue-loader 的解析中有讲解过
compiler-ssr 服务端渲染环境中的模板解析逻辑
reactivity 响应式数据相关逻辑
runtime-core 与平台无关的运行时核心，包括 render
runtime-dom 浏览器环境中的运行时核心
runtime-test 用于自动化测试的相关配套
server-renderer 用于 SSR 服务端渲染的逻辑
shared 一些各个包之间共享的公共工具
size-check 一个用于测试 tree shaking 后代码大小的示例库
template-explorer 用于检查模板编译后的输出，主要用于开发调试
vue Vue 3 的主要入口，包括运行时和编译器，包括几个不同的入口（开发版本、runtime 版本、full 版本）